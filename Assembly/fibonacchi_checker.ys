# TODO: Main
# TODO: Siivoa multiplication
# TODO: Siivoa square root
# TODO: tee funktio isPerfectSquare
# TODO: tee funktio isFibonacchi

#####################################################
# General Registers: 
# (Values will be modified between functions calls)
# %rax, %rcx, %rdx, %rbx ,%rsi, %rdi
#####################################################
# Input Registers:
# (Arguments for function calls)
# %r14, %r13, %r12
#####################################################
# Main Registers:
# (Variables and constants used by Main)
# %r8, %r9, %r10, %r11
#####################################################
main:
    irmovq pino, %rsp       # stack pointer
    irmovq pino, %rbp       # stack start
#test
    
#test
    call multiplication
    halt

#####################################################
# Multiplication
# %r14 = %r14 * %r13
#####################################################
# Multiplies together the numbers in r14 and r13
# using peasant binary algorithm
##################################################### 
# Input: %r14, %r13
# Output: %r14
# Used registers: rax, rbx, rcx, rdi, rsi, r14, r13
# TODO: Vähennä käytettyjen registerien määrää
# TODO: Varmista että suurempi luku on r14
#####################################################
.pos 0x100
multiply_r14_r13:            # %r14 = %r14 * %r13
    # initialize variables
    irmovq $1, %rbx        # bitmask = 0b1
    irmovq $0, %rdi        # output = 0
    rrmovq %r13, %rsi      # remaining = num2
    rrmovq %r14, %rcx      # bitshifted_num1 = num1 
multiplication_loop: # while(remaining != 0):
    rrmovq %rsi, %rax
    andq %rax, %rax
    je multiplication_return
    # read a bit using bitmask
    rrmovq %r13, %rax     # variable = num2
    andq %rbx, %rax       # variable = bitmask & variable
    je process_remaining
    # if(variable != 0): add bitshifted_num1 to output
    addq %rcx, %rdi       # output = bitshifted_num1 + output
process_remaining:
    rrmovq %rbx, %rax
    andq %r13, %rax
    je process_bitshifts
    # if(remaining & bitmask != 0): remove processed bit from remaining
    subq %rbx, %rsi      # remaining =  remaining - bitmask
process_bitshifts:
    # bitshift bitmask and bitshifted_num1 to the left
    addq %rbx, %rbx      # bitmask = bitmask + bitmask
    addq %rcx, %rcx      # bitshifted_num1 = bitshifted_num1 + bitshifted_num1
    jmp multiplication_loop
multiplication_return:
    rrmovq %rdi, %r14



###################################################
# Square root
# %r13 = sqrt(%r13)
###################################################
# Calculates the square root of the number in %r13
###################################################
# Input: %r13
# Output: %r13
# Used registers: rax, rbx, rcx, rdx, r13, 14
# TODO: Vähennä käytettyjen registerien määrää
###################################################
.pos 0x200
# res=%rcx, bit=%rdx, num=%r13
square_root_r13:                 # %r13 = sqrt(num)
    %irmovq $0, %rcx        # res = 0
    %irmovw $1, %rdx        # bit = 1
loop1:                      # while(bit << 2 <= num):
    # if(bit << 2 <= num) break
    rrmovq %rdx, %rax       # var = bit
    addq %rax, %rax         # var <<= 2
    addq %rax, %rax       
    rrmovq %r13, %rbx       # var2 = num
    subq %rax, %rbx         # var2 -= bit << 2
    jle loop1_return
    # bit <<= 2
    addq %rdx, %rdx        
    addq %rdx, %rdx
    jmp loop1

loop1_return:
loop2:                      # while(bit != 0)
    # if(bit != 0) return
    rrmovq %rdx, %rax
    andq %rax, %rax
    je loop2_return
    # if (num >= res + bit)
    rrmovq %rcx, %rax       # var = res
    addq %rdx, %rax         # var += bit
    subq %r13, %rax         # if(num < res + bit) jump to loop2_else
    jg loop2_else
# num -= res + bit
    rrmovq %rcx, %rax       # var = res
    addq %rdx, %rax         # var += bit
    subq %rax, %r13         # num -= var
# res = (res >> 1) + bit
    rrmovq %rcx, %r14       # var = res
    call rightshift1        # var >>= 1
    addq %rdx, %r14         # var += bit
    rrmovq %r14, %rcx       # res = var
    jmp loop2_end
loop2_else:
    # res >>= 1
    rrmovq %rcx, %r14       # var = res
    call rightshift1        # var >>= 1
    rrmovq %r14, %rcx       # res = var
loop2_end:
    # bit >>= 2
    rrmovq %rdx, %r14       # var = bit
    call rightshift2        # var >>= 2
    rrmovq %r14, %rdx       # bit = var
    jmp loop2
loop2_return:
    rrmovq %rcx, %r13
    ret

###########################################################
# rightshift1_r14
# %r14 = %r14 << 1
###########################################################
# rightshift2_r14
# %r14 = %r14 << 2
###########################################################
# Bitshifts the number in %r14 to the right by 1 or 2 bits
###########################################################
# Input: %r14
# Output: %r14
# Used registers: rax, rbx, rcx, rdx, rdi, rsi,  r13, r14
# TODO: Vähennä käytettyjen registerien määrää
###########################################################
.pos 0x300
# initialize bitmasks and zero bits that would shift past 0
rightshift1_r14:                # %r14 >>= 1
    irmovq $0x2, %rbx       # inputmask = %rbx = 0010
    irmovq $0xfffffffffffffffe,  %rax
    andq %rax, %r14         # zero lowest bit
    jmp shiftloop_start
rightshift2_r14:                # %r14 >>= 2
    irmovq $0x4, %rbx       # inputmask = %rbx = 0100
    irmovq $0xfffffffffffffffc,  %rax
    andq %rax, %r14         # zero 2 lowest bits

shiftloop_start:
    # if(result == 0) return 0
    irmovq $0, %r13         # output = 0
    je shiftloop_return
    irmovq $0x1, %rcx       # outputmask = %rcx = 0001
    rrmovq %r14, %rdx       # remaining = input
shiftloop:                  # while(remaining != 0)
    irmovq $0, %rsi         # inputbuffer = 0
    irmovq $0, %rdi         # outputbuffer = 0
    rrmovq %r14, %rax       # var = input
    andq %rbx, %rax         # var &= inputmask
    cmovne %rbx, %rsi       # if(var != 0) inputbuffer = inputputmask
    cmovne %rcx, %rdi       # if(var != 0) outputbuffer = outputmask
    addq %rdi, %r13         # output += outputbuffer
    # if(remaining == 0) return
    subq %rsi, %rdx         # remaining -= inputbuffer
    jle shiftloop_return    
    # Increment masks
    addq %rbx, %rbx         # inputmask += inputmask
    addq %rcx, %rcx         # outputmask += outputmask
    jmp shiftloop
shiftloop_return:
    rrmovq %r13, %r14
    ret

.pos 0x400
pino:                       # stack address  
