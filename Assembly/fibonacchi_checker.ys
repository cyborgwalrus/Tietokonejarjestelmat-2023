#########################################################
# Fibonacchi checker
#########################################################
# by Matias Bj√∂rklund
# 2207800
# matias.bjorklund@student.oulu.fi
#########################################################
# Input: Array in the memory location 0x700
# Output: returns 0 in the %rax register if all the 
# numbers in the array were fibonacchi numbers,
# otherwise returns the first non-fibonacchi-number found
#####################################################
# General Registers: 
# (Registers used by functions)
# %rax, %rcx, %rdx, %rbx, %r8, %r9, %r10, %r11, %r12
##########################################################
# Input/Output Registers:
# (Arguments and return values for function calls)
# %r14, %r13
##########################################################
# Other registers:
# %rsi (array pointer)
##########################################################

# TODO: Kommentteja, pohdintoja
# TODO: Testaa ei-fibonacchi-luvuilla
main:
    irmovq pino, %rsp       # stack pointer
    irmovq pino, %rbp       # stack start
    irmovq array, %rsi      # array pointer

array_loop:
    nop
    nop
    nop
    mrmovq (%rsi), %r13

    rrmovq %r13, %rax
    andq %rax, %rax
    je end_of_array_reached # if(r13 == 0) return 0
    # r13 wasnt 0, calling function
    call isFibonacchi_r13
    rrmovq %r13, %rax
    andq %rax, %rax
    je not_fibonacchi_found # if(r13 == 0) return (%rsi)
move_array_pointer:
    irmovq $8, %rax
    addq %rax, %rsi
    jmp array_loop

not_fibonacchi_found:
    # Non-fibonacchi number was found,
    # ending program with the number in %rax
    mrmovq (%rsi), %rax
    halt

end_of_array_reached:
    # all numbers where fibbonacchi numbers,
    # ending program with 0 in the %rax register
    halt


#####################################################
# isFibonacchi_r13
# %r13 = isFibonacchi_r13(%r13)
#####################################################
# Return 1 if the number in %r13 is a fibonaccchi number,
# returns 0 otherwise
##################################################### 
# Input: %r13
# Output: %r13
# Used registers: rax, r13, r14
#####################################################
.pos 0x100
isFibonacchi_r13:
    rrmovq %r13, %r9   # Save a copy of input in %r9
    
    # isPerfectSquare_r13(5*x*x + 4)
    call r13_r13_5      # input = input * input * 5
    irmovq $4, %rax   
    addq %rax, %r13     # input = input + 4
    call isPerfectSquare_r13
    # if(%r13 == 1) jump
    andq %r13, %r13
    jne r13_is_fibonacchi_number

    # isPerfectSquare_r13(5*x*x - 4)
    rrmovq %r9, %r13   # restore copy of input into r13
    
    call r13_r13_5      # input = input * input * 5
    irmovq $4, %rax   
    subq %rax, %r13     # input = input - 4
    call isPerfectSquare_r13
    # if(%r13 == 1) jump
    andq %r13, %r13
    jne r13_is_fibonacchi_number

r13 is_not_fibonacchi_number:
    irmovq $0, %r13
    ret
r13_is_fibonacchi_number:
    irmovq $1, %r13
    ret

r13_r13_5: # %r13 = %r13 * %r13 * 5
    rrmovq %r13, %r14
    call multiply_r13_r14
    irmovq $5, %r13
    call multiply_r13_r14
    rrmovq %r14, %r13
    ret

#####################################################
# isPerfectSquare_r13
# %r13 = isPerfectSquare_r13(%r13)
#####################################################
# Return 1 if the number in %r13 is perfect square,
# return 0 otherwise
##################################################### 
# Input: %r13
# Output: %r13
# Used registers: rax, r13, r14
#####################################################
.pos 0x200
isPerfectSquare_r13:
    rrmovq %r13, %r8        # var = input
    call square_root_r13     # arg1 = sqrt(input)
    rrmovq %r13, %r14        # arg2 = arg1
    call multiply_r13_r14    # arg2 = arg1 * arg2
    
    # if(var == arg1 * arg2) return 1
    # else return 0 
    subq %r14, %r8
    je r13_is_perfect_square
r13_is_not_perfect_square:
    irmovq $0, %r13
    ret
r13_is_perfect_square:
    irmovq $1, %r13
    ret

#####################################################
# Multiplication
# %r14 = %r14 * %r13
#####################################################
# Multiplies together the numbers in r14 and r13
# using peasant binary algorithm
##################################################### 
# Input: %r14, %r13
# Output: %r14
# Used registers: rax, rbx, rcx, rdi, r14, r13
#####################################################
.pos 0x300
multiply_r13_r14:            # %r14 = %r14 * %r13
    # initialize variables
    irmovq $1, %rbx        # bitmask = 0b1
    irmovq $0, %rdi        # output = 0
    rrmovq %r13, %rdx      # remaining = num2
    rrmovq %r14, %rcx      # bitshifted_num1 = num1 
multiplication_loop: # while(remaining != 0):
    rrmovq %rdx, %rax
    andq %rax, %rax
    je multiplication_return
    # read a bit using bitmask
    rrmovq %r13, %rax     # variable = num2
    andq %rbx, %rax       # variable = bitmask & variable
    je process_remaining
    # if(variable != 0): add bitshifted_num1 to output
    addq %rcx, %rdi       # output = bitshifted_num1 + output
process_remaining:
    rrmovq %rbx, %rax
    andq %r13, %rax
    je process_bitshifts
    # if(remaining & bitmask != 0): remove processed bit from remaining
    subq %rbx, %rdx      # remaining =  remaining - bitmask
process_bitshifts:
    # bitshift bitmask and bitshifted_num1 to the left
    addq %rbx, %rbx      # bitmask = bitmask + bitmask
    addq %rcx, %rcx      # bitshifted_num1 = bitshifted_num1 + bitshifted_num1
    jmp multiplication_loop
multiplication_return:
    rrmovq %rdi, %r14
    ret


###################################################
# Square root
# %r13 = sqrt(%r13)
###################################################
# Calculates the square root of the number in %r13
###################################################
# Input: %r13
# Output: %r13
# Used registers: rax, rbx, rcx, rdx, r11, r12, r13, r14
###################################################
.pos 0x400
# res=%r11, bit=%r12, num=%r13
square_root_r13: # %r13 = sqrt(num)
    irmovq $0, %r11        # res = 0
    irmovq $1, %r12        # bit = 1

loop1:                      # while(bit << 2 <= num):
    # if(bit << 2 <= num) break
    rrmovq %r12, %rax       # var = bit
    addq %rax, %rax         # var <<= 2
    addq %rax, %rax       
    rrmovq %r13, %rbx       # var2 = num
    subq %rax, %rbx         # var2 -= bit << 2
    jl loop1_return
    # bit <<= 2
    addq %r12, %r12        
    addq %r12, %r12
    jmp loop1

loop1_return:
# res=%r11, bit=%r12, num=%r13
loop2:                      # while(bit != 0)
    # if(bit == 0) return
    rrmovq %r12, %rax
    andq %rax, %rax
    je loop2_return
    # if (num >= res + bit)
    rrmovq %r11, %rax       # var = res
    addq %r12, %rax         # var += bit
    subq %r13, %rax         # if(num < res + bit) jump to loop2_else
    jg loop2_else
    # num -= res + bit
    rrmovq %r11, %rax       # var = res
    addq %r12, %rax         # var += bit
    subq %rax, %r13         # num -= var
    # res = (res >> 1) + bit
    rrmovq %r11, %r14       # var = res
    call rightshift1_r14        # var >>= 1
    addq %r12, %r14         # var += bit
    rrmovq %r14, %r11       # res = var
    jmp loop2_end
loop2_else:
    # res >>= 1
    rrmovq %r11, %r14       # var = res
    call rightshift1_r14        # var >>= 1
    rrmovq %r14, %r11       # res = var
loop2_end:
    # bit >>= 2
    rrmovq %r12, %r14       # var = bit
    call rightshift2_r14        # var >>= 2
    rrmovq %r14, %r12       # bit = var
    jmp loop2
loop2_return:
    rrmovq %r11, %r13
    ret
###########################################################
# rightshift1_r14
# %r14 = %r14 << 1
###########################################################
# rightshift2_r14
# %r14 = %r14 << 2
###########################################################
# Bitshifts the number in %r14 to the right by 1 or 2 bits
###########################################################
# Input: %r14
# Output: %r14
# Used registers: rax, rbx, rcx, rdx, rdi, r13, r14
###########################################################
.pos 0x500
# initialize bitmasks and zero bits that would shift past 0
rightshift1_r14:                # %r14 >>= 1
    irmovq $0x2, %rbx       # inputmask = %rbx = 0010
    irmovq $0xfffffffffffffffe,  %rax
    andq %rax, %r14         # zero lowest bit
    jmp shiftloop_start
rightshift2_r14:                # %r14 >>= 2
    irmovq $0x4, %rbx       # inputmask = %rbx = 0100
    irmovq $0xfffffffffffffffc,  %rax
    andq %rax, %r14         # zero 2 lowest bits

shiftloop_start:
    # if(result == 0) return 0
    irmovq $0, %rdi         # output = 0
    je shiftloop_return
    irmovq $0x1, %rcx       # outputmask = %rcx = 0001
    rrmovq %r14, %rdx       # remaining = input
shiftloop:                  # while(remaining != 0)
    rrmovq %r14, %rax       # var = input
    andq %rbx, %rax         # var &= inputmask
    je read_bit_was_0
read_bit_was_1:
    addq %rcx, %rdi         # output += outputmask
    subq %rbx, %rdx         # remaining -= inputmask
    # if(remaining == 0) return
    jle shiftloop_return    
read_bit_was_0:
    # Increment masks
    addq %rbx, %rbx         # inputmask += inputmask
    addq %rcx, %rcx         # outputmask += outputmask
    jmp shiftloop
shiftloop_return:
    rrmovq %rdi, %r14
    ret

.pos 0x600
pino:                       # stack address

.pos 0x700
.align 8
array:
.quad 0x1
.quad 0x2
.quad 0x3
.quad 0x5
.quad 0x8
.quad 0xd
.quad 0x15
.quad 0x22
.quad 0x37
.quad 0x59
.quad 0x90
.quad 0xe9
.quad 0x179
.quad 0x262
.quad 0x3db
.quad 0x63d
.quad 0xa18
.quad 0x1055
.quad 0x1a6d
.quad 0x2ac2
