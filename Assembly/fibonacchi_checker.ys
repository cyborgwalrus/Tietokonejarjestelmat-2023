# TODO: Main
# TODO: isFibonacchi_r13 palauttaa aina 0, syynä square root?
# TODO: square rootissa bugeja, sqrt(9) = 0???

#####################################################
# General Registers: 
# (Temporary registers used by functions internally)
# %rax, %rcx, %rdx, %rbx ,%rsi, %rdi
#####################################################
# Input/Output Registers:
# (Arguments for function calls)
# %r14, %r13, %r12
#####################################################
# Main Registers:
# (For variables and constants used by Main)
# %r8, %r9, %r10, %r11
#####################################################
main:
    irmovq pino, %rsp       # stack pointer
    irmovq pino, %rbp       # stack start
#test
    irmovq $13, %r13
    call isFibonacchi_r13
    rrmovq %r13, %rax
#test
    halt


#####################################################
# isFibonacchi_r13
# %r13 = isFibonacchi_r13(%r13)
#####################################################
# Return 1 if the number in %r13 is a fibonaccchi number,
# returns 0 otherwise
##################################################### 
# Input: %r13
# Output: %r13
# Used registers: rax, r13, r14
#####################################################
.pos 0x100
isFibonacchi_r13:
    rrmovq %r13, %r9   # Save a copy of input in %r9
    
    # isPerfectSquare_r13(5*x*x + 4)
    call r13_r13_5      # input = input * input * 5
    irmovq $4, %rax   
    addq %rax, %r13     # input = input + 4
    call isPerfectSquare_r13
    jne r13_is_fibonacchi_number

    # isPerfectSquare_r13(5*x*x - 4)
    rrmovq %r9, %r13   # restore copy of input into r13
    
    call r13_r13_5      # input = input * input * 5
    irmovq $4, %rax   
    subq %rax, %r13     # input = input - 4
    call isPerfectSquare_r13
    jne r13_is_fibonacchi_number

r13 is_not_fibonacchi_number:
    irmovq $0, %r13
    ret
r13_is_fibonacchi_number:
    irmovq $1, %r13
    ret

r13_r13_5: # %r13 = %r13 * %r13 * 5
    rrmovq %r13, %r14
    call multiply_r13_r14
    irmovq $5, %r13
    call multiply_r13_r14
    rrmovq %r14, %r13
    ret

#####################################################
# isPerfectSquare_r13
# %r13 = isPerfectSquare_r13(%r13)
#####################################################
# Return 1 if the number in %r13 is perfect square,
# return 0 otherwise
##################################################### 
# Input: %r13
# Output: %r13
# Used registers: rax, r13, r14
#####################################################
.pos 0x200
isPerfectSquare_r13:
    rrmovq %r13, %r10        # var = input
    call square_root_r13     # arg1 = sqrt(input)
    rrmovq %r13, %r14        # arg2 = arg1
    call multiply_r13_r14    # arg2 = arg1 * arg2
    
    # if(var == arg1 * arg2) return 1
    # else return 0 
    subq %r14, %r10
    je r13_is_perfect_square
r13_is_not_perfect_square:
    xorq %rax, %rax
    irmovq $0, %r13
    ret
r13_is_perfect_square:
    xorq %rax, %rax
    irmovq $1, %r13
    ret

#####################################################
# Multiplication
# %r14 = %r14 * %r13
#####################################################
# Multiplies together the numbers in r14 and r13
# using peasant binary algorithm
##################################################### 
# Input: %r14, %r13
# Output: %r14
# Used registers: rax, rbx, rcx, rdi, rsi, r14, r13
# TODO: Vähennä käytettyjen registerien määrää
# TODO: Varmista että suurempi luku on r14
#####################################################
.pos 0x300
multiply_r13_r14:            # %r14 = %r14 * %r13
    # initialize variables
    irmovq $1, %rbx        # bitmask = 0b1
    irmovq $0, %rdi        # output = 0
    rrmovq %r13, %rsi      # remaining = num2
    rrmovq %r14, %rcx      # bitshifted_num1 = num1 
multiplication_loop: # while(remaining != 0):
    rrmovq %rsi, %rax
    andq %rax, %rax
    je multiplication_return
    # read a bit using bitmask
    rrmovq %r13, %rax     # variable = num2
    andq %rbx, %rax       # variable = bitmask & variable
    je process_remaining
    # if(variable != 0): add bitshifted_num1 to output
    addq %rcx, %rdi       # output = bitshifted_num1 + output
process_remaining:
    rrmovq %rbx, %rax
    andq %r13, %rax
    je process_bitshifts
    # if(remaining & bitmask != 0): remove processed bit from remaining
    subq %rbx, %rsi      # remaining =  remaining - bitmask
process_bitshifts:
    # bitshift bitmask and bitshifted_num1 to the left
    addq %rbx, %rbx      # bitmask = bitmask + bitmask
    addq %rcx, %rcx      # bitshifted_num1 = bitshifted_num1 + bitshifted_num1
    jmp multiplication_loop
multiplication_return:
    rrmovq %rdi, %r14
    ret


###################################################
# Square root
# %r13 = sqrt(%r13)
###################################################
# Calculates the square root of the number in %r13
###################################################
# Input: %r13
# Output: %r13
# Used registers: rax, rbx, rcx, rdx, r13, 14
# TODO: Vähennä käytettyjen registerien määrää
###################################################
.pos 0x400
# res=%rcx, bit=%rdx, num=%r13
square_root_r13: # %r13 = sqrt(num)
    irmovq $0, %rcx        # res = 0
    irmovq $1, %rdx        # bit = 1
loop1:                      # while(bit << 2 <= num):
    # if(bit << 2 <= num) break
    rrmovq %rdx, %rax       # var = bit
    addq %rax, %rax         # var <<= 2
    addq %rax, %rax       
    rrmovq %r13, %rbx       # var2 = num
    subq %rax, %rbx         # var2 -= bit << 2
    jle loop1_return
    # bit <<= 2
    addq %rdx, %rdx        
    addq %rdx, %rdx
    jmp loop1

loop1_return:
loop2:                      # while(bit != 0)
    # if(bit != 0) return
    rrmovq %rdx, %rax
    andq %rax, %rax
    je loop2_return
    # if (num >= res + bit)
    rrmovq %rcx, %rax       # var = res
    addq %rdx, %rax         # var += bit
    subq %r13, %rax         # if(num < res + bit) jump to loop2_else
    jg loop2_else
# num -= res + bit
    rrmovq %rcx, %rax       # var = res
    addq %rdx, %rax         # var += bit
    subq %rax, %r13         # num -= var
# res = (res >> 1) + bit
    rrmovq %rcx, %r14       # var = res
    call rightshift1_r14        # var >>= 1
    addq %rdx, %r14         # var += bit
    rrmovq %r14, %rcx       # res = var
    jmp loop2_end
loop2_else:
    # res >>= 1
    rrmovq %rcx, %r14       # var = res
    call rightshift1_r14        # var >>= 1
    rrmovq %r14, %rcx       # res = var
loop2_end:
    # bit >>= 2
    rrmovq %rdx, %r14       # var = bit
    call rightshift2_r14        # var >>= 2
    rrmovq %r14, %rdx       # bit = var
    jmp loop2
loop2_return:
    rrmovq %rcx, %r13
    ret

###########################################################
# rightshift1_r14
# %r14 = %r14 << 1
###########################################################
# rightshift2_r14
# %r14 = %r14 << 2
###########################################################
# Bitshifts the number in %r14 to the right by 1 or 2 bits
###########################################################
# Input: %r14
# Output: %r14
# Used registers: rax, rbx, rcx, rdx, rdi, rsi,  r13, r14
# TODO: Vähennä käytettyjen registerien määrää
###########################################################
.pos 0x500
# initialize bitmasks and zero bits that would shift past 0
rightshift1_r14:                # %r14 >>= 1
    irmovq $0x2, %rbx       # inputmask = %rbx = 0010
    irmovq $0xfffffffffffffffe,  %rax
    andq %rax, %r14         # zero lowest bit
    jmp shiftloop_start
rightshift2_r14:                # %r14 >>= 2
    irmovq $0x4, %rbx       # inputmask = %rbx = 0100
    irmovq $0xfffffffffffffffc,  %rax
    andq %rax, %r14         # zero 2 lowest bits

shiftloop_start:
    # if(result == 0) return 0
    irmovq $0, %r13         # output = 0
    je shiftloop_return
    irmovq $0x1, %rcx       # outputmask = %rcx = 0001
    rrmovq %r14, %rdx       # remaining = input
shiftloop:                  # while(remaining != 0)
    irmovq $0, %rsi         # inputbuffer = 0
    irmovq $0, %rdi         # outputbuffer = 0
    rrmovq %r14, %rax       # var = input
    andq %rbx, %rax         # var &= inputmask
    cmovne %rbx, %rsi       # if(var != 0) inputbuffer = inputputmask
    cmovne %rcx, %rdi       # if(var != 0) outputbuffer = outputmask
    addq %rdi, %r13         # output += outputbuffer
    # if(remaining == 0) return
    subq %rsi, %rdx         # remaining -= inputbuffer
    jle shiftloop_return    
    # Increment masks
    addq %rbx, %rbx         # inputmask += inputmask
    addq %rcx, %rcx         # outputmask += outputmask
    jmp shiftloop
shiftloop_return:
    rrmovq %r13, %r14
    ret

.pos 0x600
pino:                       # stack address  
