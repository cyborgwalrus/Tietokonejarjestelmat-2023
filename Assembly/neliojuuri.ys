# TODO: bitshift toimii
# Test Code should return %rcx = 48
.pos 0
                            # res = %r10
    irmovq $0x10000, %r11   # bit = %r11 = 0x1000
    irmovq $2345, %r12      # num = %r12

main:
    irmovq pino, %rsp       # stack pointer
    irmovq pino, %rbp       # stack start
    irmovq $1, %r8          # constant 1
    call neliojuuri
    halt

.pos 0x100
# res=%r10, bit=%r11, num=%r12
neliojuuri:                 # %rcx = sqrt(num)
loop1:                      # while(bit > num) bit >>= 2;
    rrmovq %r11, %r14       # var = bit
    call rightshift2        # var >>= 2
    rrmovq %r14, %r11       # bit = var
    # Loop checking
    rrmovq %r12, %rax
    subq %r11, %rax
    jle loop1
loop2:                      # while(bit != 0)
    rrmovq %r10, %rax       # var = res
    addq %r11, %rax         # var += bit
    subq %r12, %rax         # if(num < var) jump to loop2_else
    jl loop2_else
# num -= res + bit
    rrmovq %r10, %rax       # var = res
    addq %r11, %rax         # var += bit
    subq %rax, %r12         # num -= var
# res = (res >> 1) + bit
    rrmovq %r10, %r14       # var = res
    call rightshift1        # var >>= 1
    addq %r11, %r14         # var += bit
    rrmovq %r14, %r10       # res = var
    jmp loop2_end
loop2_else:
    rrmovq %r10, %r14       # var = res
    call rightshift1        # var >>= 1
    rrmovq %r14, %r10       # res = var
loop2_end:
    rrmovq %r11, %r14       # var = bit
    call rightshift2        # var >>= 2
    rrmovq %r14, %r11       # bit = var
    # TODO: 
    # Loop checking
    rrmovq %r11, %rax
    andq %rax, %rax
    jne loop2
    ret

.pos 0x200
rightshift1:                 # %r14 = %r14 >> 1
    irmovq $0x2, %rbx       # inputmask = %rbx = 0010
    irmovq $0xfffffffffffffffe,  %rax
    andq %rax, %r14         # zero out lowest bit
    jmp shiftloop_start
rightshift2:                # %r14 = %r14 >> 2
    irmovq $0x4, %rbx       # inputmask = %rbx = 0100
    irmovq $0xfffffffffffffffc,  %rax
    andq %rax, %r14         # zero out 2 lowest bits
shiftloop_start:
    irmovq $0x1, %rcx       # outputmask = %rcx = 0001
    rrmovq %r14, %r10       # remaining = input
shiftloop:                  # while(remaining != 0)
    irmovq $0, %rdx         # outputbuffer = 0
    rrmovq %r14, %rax       # var = input
    andq %rbx, %rax         # var &= inputmask
    cmovne %rcx, %rdx       # if(var != 0) outputbuffer = outputmask
    addq %rdx, %r13         # output += outputbuffer
    # Loop checking
    subq %rbx, %r10         # remaining -= inputmask
    jle shiftloop_end       # if(remaining == 0) jump to end
    # Increment masks
    addq %rbx, %rbx         # inputmask += inputmask
    addq %rcx, %rcx         # outputmask += outputmask
    jmp shiftloop
shiftloop_end:
    rrmovq %r13, %r14
    ret

.pos 0x400
pino:                       # stack address  
    ret

.pos 0x400
pino:                       # stack address  
