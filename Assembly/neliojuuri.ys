# TODO: bitshift toimii
# Test Code should return %rcx = 48
main:
    irmovq pino, %rsp       # stack pointer
    irmovq pino, %rbp       # stack start
    irmovq $0, %r10         # res = %r10 = 0
    irmovq $1, %r11         # bit = %r11 = 1
    irmovq $2345, %r12      # num = %r12
    call neliojuuri
    halt

.pos 0x100
# res=%r10, bit=%r11, num=%r12
neliojuuri:                 # %rcx = sqrt(num)
loop1:                      # while(bit << 2 <= num):
    # Loop checking
    rrmovq %r11, %rax       # var = bit
    addq %rax, %rax         # var <<= 2
    addq %rax, %rax       
    rrmovq %r12, %rbx       # var2 = num
    subq %rax, %rbx         # var2 -= bit << 2
    jle loop1_return
    rrmovq %rax, %r11       # bit = var
    jmp loop1

loop1_return:
loop2:                      # while(bit != 0)
    # Loop checking
    rrmovq %r11, %rax
    andq %rax, %rax
    je loop2_return
    # if (num >= res + bit)
    rrmovq %r10, %rax       # var = res
    addq %r11, %rax         # var += bit
    subq %r12, %rax         # if(num < var) jump to loop2_else
    jge loop2_else
# num -= res + bit
    rrmovq %r10, %rax       # var = res
    addq %r11, %rax         # var += bit
    subq %rax, %r12         # num -= var
# res = (res >> 1) + bit
    rrmovq %r10, %r14       # var = res
    call rightshift1        # var >>= 1
    addq %r11, %r14         # var += bit
    rrmovq %r14, %r10       # res = var
    jmp loop2_end
loop2_else:
    rrmovq %r10, %r14       # var = res
    call rightshift1        # var >>= 1
    rrmovq %r14, %r10       # res = var
loop2_end:
    rrmovq %r11, %r14       # var = bit
    call rightshift2        # var >>= 2
    rrmovq %r14, %r11       # bit = var
    jmp loop2
loop2_return:
    rrmovq %r10, %rcx
    ret

.pos 0x200
# initialize bitmasks and zero bits that would shift past 0
rightshift1:                # %r14 = %r14 >> 1
    irmovq $0x2, %rbx       # inputmask = %rbx = 0010
    irmovq $0xfffffffffffffffe,  %rax
    andq %rax, %r14         # zero lowest bit
    jmp shiftloop_start
rightshift2:                # %r14 = %r14 >> 2
    irmovq $0x4, %rbx       # inputmask = %rbx = 0100
    irmovq $0xfffffffffffffffc,  %rax
    andq %rax, %r14         # zero 2 lowest bits

shiftloop_start:
    irmovq $0x1, %rcx       # outputmask = %rcx = 0001
    rrmovq %r14, %r10       # remaining = input
    irmovq $0, %r13         # output = 0
shiftloop:                  # while(remaining != 0)
    irmovq $0, %r12         # inputbuffer = 0
    irmovq $0, %r11         # outputbuffer = 0
    rrmovq %r14, %rax       # var = input
    andq %rbx, %rax         # var &= inputmask
    cmovne %rbx, %r12       # if(var != 0) inputbuffer = inputputmask
    cmovne %rcx, %r11       # if(var != 0) outputbuffer = outputmask
    addq %r11, %r13         # output += outputbuffer
    # Loop checking
    subq %r12, %r10         # remaining -= inputbuffer
    jle shiftloop_return    # if(remaining == 0) jump to end
    # Increment masks
    addq %rbx, %rbx         # inputmask += inputmask
    addq %rcx, %rcx         # outputmask += outputmask
    jmp shiftloop
shiftloop_return:
    rrmovq %r13, %r14
    ret

.pos 0x400
pino:                       # stack address  
